---
title: Testing embedded C++ with Haskell QuickCheck
tags: programming, haskell
---

There seems to be some confusion about the use of testing C++ code with
[QuickCheck] [qc] from Haskell. That it can't be done, in fact. This
isn't true, it can definitely be done, with two caveats.

*   The code under test needs to be C-compatible, so using `extern C`
    otherwise the name mangler will prevent your linker from finding the
    correct symbols.
*   You have to manage the compilation steps manually or using an
    ordinary Makefile. The CABAL system doesn't recognise `.cpp` files
    so won't process them properly on its own.

These are not grave restrictions by any means. This is how it's done.
First, we will see the files we have to start with. These are the ones
which we have to write and cannot be autogenerated:

    foo.cpp # The C++ code we want to test
    foo.h   # and its attendant header file

    Foo.hsc # The bridge file between C and Haskell types
    Main.hs # The Haskell code to run tests

## Some code to test

A simple struct and a pair of functions that should operate as a "round
trip", serialising and then deserialising the input.

```cpp { "foo.cpp" }
```

I've hard-coded lots of stuff there, all the indices and the bytes read
and written. I've also put an obvious bug into the indices to show the
checker working. The header file is also important, because it defines
what the interface is to the Haskell side (or any other code).

```cpp { "foo.h" }
```

As I said before, you need to ensure the `extern "C"` stuff is there
otherwise you'll fail at the linking stage. This means that polymorphic
C++ code won't work directly --- you'll have to write a C wrapper and
attach to that.

To run Haskell tests on C++ code we need the C++ object file. I'm using
the filename `foo.cpp.o` instead of `foo.o` here to highlight an
important point. If you're compiling all this in the same directory as
the Haskell code, and you've got a `foo.cpp` and a `Foo.hs` then GHC
will likely clobber the object file you've already written --- it
doesn't pay attention to difference in case. So for simplicity's sake,
either rename the Haskell source file so it's not the same or rename the
C/C++ object file so it's not the same.

```bash
$ gcc -o foo.cpp.o -c foo.cpp
```

If you forgot to tell the compiler that these are C-compatible functions
with the `extern` keyword then the output will look like this:

```bash
$ nm foo.cpp.o
0000000000000148 s EH_frame0
00000000000000b0 T __Z11deserialisePKhP3foo
0000000000000190 S __Z11deserialisePKhP3foo.eh
0000000000000000 T __Z9serialisePK3fooPh
0000000000000160 S __Z9serialisePK3fooPh.eh
```

whereas we want them to look more like this:

```bash
$ nm foo.cpp.o
0000000000000148 s EH_frame0
00000000000000b0 T _deserialise
0000000000000190 S _deserialise.eh
0000000000000000 T _serialise
0000000000000160 S _serialise.eh
```

* * *

and we need Haskell types which can be marshalled to and from the C++
types which the functions in `foo.cpp` expect. The creation of a `.hsc`
file is [well documented by Magnus Therning][hsc] though I may cover it
in more detail in future.


```bash
$ hsc2hs Foo.hsc
```

At this stage we've got a couple more files to play with:

    foo.o
    Foo.hs

If the marshalling in `Foo.hsc` is defined correctly you should be able
to load the generated Haskell file into GHCi alongside the C++ object
file to exercise it.

```bash
$ ghci Foo.hs foo.o
```

All that's needed now is your tests. If the code you are testing does
not maintain state then all the better: you can wrap the FFI calls in
`unsafePerformIO` to convince the type system that they're pure
computations.

```bash
$ ghc --make Main.hs foo.o -o tests
```

[qc]: <http://hackage.haskell.org/package/QuickCheck>
    "A library for random testing of program properties"

[hsc]: <http://therning.org/magnus/archives/315>
    "Using hsc2hs to marshall C structs"
